[[rql-parser]]
= RQL Parser

This Maven module contains the antlr4 grammar as well as the parser to create the _RqlQueryModel_ from a string or vice versa.
The parser is the central tool that uses antlr4 code to analyze RQL queries and convert them into an _RqlQueryModel_.
Therefore, this module enables the interpretation of RQL queries in string format and transforms them into an internal model (RqlQueryModel) that can be further processed.

To include the plugin, use the following dependency:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>com.boschsemanticstack</groupId>
    <artifactId>semanticstack-rql-parser</artifactId>
    <version>{version}</version>
</dependency>
----

== Creation of a model

To create a model we can use _RqlParser.builder()_.
This maps the structure such as _select_, _filter_ and _option_.

[source,java,indent=0,subs="+macros,+quotes"]
----
      final RqlQueryModel model = RqlParser.builder()
            .select( "att1", "att2", "att3/subAtt4" )
            .filter( RqlBuilder.and(
                  RqlBuilder.eq( "att2", "theSame" ),
                  RqlBuilder.or(
                        RqlBuilder.lt( "att1", 5238907523475022349L ),
                        RqlBuilder.not(
                              RqlBuilder.gt( "att1", new BigInteger( "12345678901234567890123456789012345678901234567890" ) )
                        )
                  ) ) )
            .sort( RqlBuilder.asc( "att1" ), RqlBuilder.desc( "att2" ) )
            .limit( 0, 500 )
            .build();
----

=== Creating a string representation of the model

To create a string representation of the model, we can use the _toString()_ method of the _RqlParser_.

[source,java,indent=0,subs="+macros,+quotes"]
----
      final String representation = RqlParser.toString( model );

----

==== Single argument or body

Do you transport the query via html body or as a single query attribute?
To parse a query from Rest:

[source,java,indent=0,subs="+macros,+quotes"]
----
   private void someRestEndpoint( final String theWholeQuery ) {//<1>

      // this highly depends on your rest backend therefore no api call to do this is provided
      final RqlQueryModel from = RqlParser.from( Optional.ofNullable( theWholeQuery ).orElse( "" ) );

      // do something with query model
   }

----

<1> the whole query taken from the html-body or a single query argument.

==== As multiple query parameters

Parsing a query transported component-wise (as three independent query arguments) requires re-assembly:

[source,java,indent=0,subs="+macros,+quotes"]
----
   private void someRestEndpoint(
         final String selectParam, // <2>
         final String filterParam, // <2>
         final String optionParam ) { //<2>

      final String queryString = Stream.of(
                  Optional.ofNullable( selectParam ).map( s -> "select=" ), // <1>
                  Optional.ofNullable( filterParam ).map( s -> "filter=" ), // <1>
                  Optional.ofNullable( optionParam ).map( s -> "option=" )  // <1>
            )
            .filter( Optional::isPresent )
            .map( Optional::get )
            .collect( Collectors.joining( "&" ) );

      final RqlQueryModel from = RqlParser.from( queryString );

      // do something with query model
   }
----

<1> the whole query taken from the html-body or a single query argument.
<2> the parameter names on your api do not even need to be named `select,filter or query` they could be named `fields,restrictions,settings`

==== To query a RQL-supporting Service:

[source,java,linenums,options="nowrap"]
----
   private Observable<RestResponse> getSomeResourceWithRqlUsingQueryParameters( final RqlQueryModel query ) {

      final Map<String, String> queryParameters = RqlParser.toQueryParameters( query );

      return someRestClient.post( "someAddress" )
            .addQueryParam( "select", queryParameters.get( "select" ) ) // <1>
            .addQueryParam( "filter", queryParameters.get( "filter" ) ) // <1>
            .addQueryParam( "option", queryParameters.get( "option" ) ) // <1>
            .toObservableResponse();
   }
----

<1> Be mindful, that each parameter part may be empty (not present in Map)

=== Adding restrictions to a model

Often you need to enforce certain restrictions on a query that may not be circumvented by the query itself.
E.g. restricting the query to a certain tenant or time frame.
To do this the `Rql` companion object supports adding restrictions _around_ the original query (as a top-level `and(...)`):

[source,java,linenums,options="nowrap"]
----
      final RqlQueryModel modelWithRestriction = RqlParser.addRestriction(
            model,
            RqlBuilder.eq( "att2", "fizzBuzz" ), // <1>
            RqlBuilder.or( RqlBuilder.ne( "att3", 42 ) ) // <2>
      );
----

<1> if the given model already has `and` as its top restriction a new `and`-clause is created using the original and new restrictions.
<2> more than one added restriction is added to only one new `and` filter.

=== Accessing a paged Service

Sometimes a service you want to access limits its pagesize to something smaller than you need.
In this case you need to query multiple times to get all data.
This can be expressed elegantly using the following construct:

[source,java,linenums,options="nowrap"]
----
   public Observable<String> getSomethingRemote( final RqlQueryModel query ) { // <1>
      final int pageSize = 170;  // entirely dependent on remote Service
      return getSomeResourceRecursive( RqlParser.getPagedQuery( query, pageSize ) );
   }

   private Observable<String> getSomeResourceRecursive( final Iterator<RqlQueryModel> pagedQuery ) {

      if ( pagedQuery.hasNext() ) {
         final RqlQueryModel next = pagedQuery.next();
         return someRestClient.post( "someAddress" )
               .withBody( new RqlToStringWriter().visitModel( next ) )
               .toObservableResponse()
               .flatMap( response -> doRecursionIfMoreMeasurementsAvailable(
                     pagedQuery,
                     next.getOptions().getSlice().get().limit(), //<2>
                     response )
               );
      }
      return Observable.empty();
   }

   private Observable<String> doRecursionIfMoreMeasurementsAvailable(
         final Iterator<RqlQueryModel> pagedQuery,
         final long pageSize,
         final RestResponse response ) {

      if ( response.getResponseCode() != 200 ) {
         return Observable.error( new RuntimeException( "Remote service responded with " + response.getResponseCode() ) );
      }

      final List<String> results = response.getBodyAsList();
      Observable<String> observableResults = Observable.fromIterable( results );

      if ( results.size() == pageSize && pagedQuery.hasNext() ) { //<3>
         observableResults = observableResults.concatWith( Observable.defer(//<4>
               () -> getSomeResourceRecursive( pagedQuery ) )
         );
      }

      return observableResults;
   }
----

<1> the original Query may well have defined it's own slice (e.g. [25:701]) this is honored throughout the process.
<2> always exists in models generated by `Rql.getPagedQuery`
<3> continue requesting as long as a) the remote service returns as many items as requested and b) there are still more items to be requested in the original query
<4> the deferral is needed so another request is only made after we get to this element... otherwise a `.take(15)` further up the stream would not take effect until all elements had been fetched

