[[rql-parser]]
= RQL Parser

This Maven module contains the antlr4 grammar as well as the parser to create the _RqlQueryModel_ from a string or vice versa.
The parser is the central tool that uses antlr4 code to analyze RQL queries and convert them into an _RqlQueryModel_.
Therefore, this module enables the interpretation of RQL queries in string format and transforms them into an internal model (RqlQueryModel) that can be further processed.

To include the plugin, use the following dependency:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>com.boschsemanticstack</groupId>
    <artifactId>semanticstack-rql-parser</artifactId>
    <version>{version}</version>
</dependency>
----

== Creation of a model

To create a model we can use _RqlParser.builder()_.
This maps the structure such as _select_, _filter_ and _option_.

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$RqlParserTest.java[tags=build_model]
----

=== Creating a string representation of the model

To create a string representation of the model, we can use the _toString()_ method of the _RqlParser_.

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$RqlParserTest.java[tags=build_model]
----

==== Single argument or body

Do you transport the query via html body or as a single query attribute?
To parse a query from Rest:

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$QueryHandlingExample.java[tags=parse_query_wholeQuery]
----

<1> the whole query taken from the html-body or a single query argument.

==== As multiple query parameters

Parsing a query transported component-wise (as three independent query arguments) requires re-assembly:

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$QueryHandlingExample.java[tags=parse_query_single]
----

<1> the whole query taken from the html-body or a single query argument.
<2> the parameter names on your api do not even need to be named `select,filter or query` they could be named `fields,restrictions,settings`

==== To query a RQL-supporting Service:

[source,java,linenums,options="nowrap"]
----
include::example$QueryHandlingExample.java[tags=send_query]
----

<1> Be mindful, that each parameter part may be empty (not present in Map)

=== Adding restrictions to a model

Often you need to enforce certain restrictions on a query that may not be circumvented by the query itself.
E.g. restricting the query to a certain tenant or time frame.
To do this the `Rql` companion object supports adding restrictions _around_ the original query (as a top-level `and(...)`):

[source,java,linenums,options="nowrap"]
----
include::example$RqlParserTest.java[tags=model_addingRestrictions]
----

<1> if the given model already has `and` as its top restriction a new `and`-clause is created using the original and new restrictions.
<2> more than one added restriction is added to only one new `and` filter.

=== Accessing a paged Service

Sometimes a service you want to access limits its pagesize to something smaller than you need.
In this case you need to query multiple times to get all data.
This can be expressed elegantly using the following construct:

[source,java,linenums,options="nowrap"]
----
include::example$AccessPagedResourceExample.java[tags=recursive_restrequest]
----

<1> the original Query may well have defined it's own slice (e.g. [25:701]) this is honored throughout the process.
<2> always exists in models generated by `Rql.getPagedQuery`
<3> continue requesting as long as a) the remote service returns as many items as requested and b) there are still more items to be requested in the original query
<4> the deferral is needed so another request is only made after we get to this element... otherwise a `.take(15)` further up the stream would not take effect until all elements had been fetched

